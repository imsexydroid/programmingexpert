{"uid":"object-oriented-programming-assessment","name":"Object-Oriented Programming Assessment","questions":[{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["programmingexpert"]},"category":"ObjectOrientedProgrammingAssessments","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["programmingexpert"]},"assessmentSummary":null,"category":"ObjectOrientedProgrammingAssessments","changelog":[],"customInputVars":[],"difficulty":1,"hints":["\u003cp\u003e\n  You'll need to create an attribute in the class to hold the inventory items.\n  What data type is the best choice for this attribute? Is there a structure\n  that lets you easily look up items by their \u003cspan\u003eitem_id\u003c/span\u003e.\n\u003c/p\u003e\n","\n\u003cp\u003e\n  You may use any data structure you like to hold items but a dictionary is the\n  best choice. You can have each key in the dictionary be the id of the item and\n  then have the value be another dictionary that looks like the following\n  \u003cspan\u003e{\"name\": \"item_name\", \"price\": item_price}\u003c/span\u003e.\n\u003c/p\u003e\n","\n\u003cp\u003e\n  If you are using a dictionary it's very easy to determine if items exists\n  already and to add and remove new items. You can use the\n  \u003cspan\u003ein\u003c/span\u003e operator to determine if items exists in the dictionary and\n  the following syntax: \u003cspan\u003edel dictionary[key]\u003c/span\u003e to delete items with\n  specific keys.\n\u003c/p\u003e\n","\n\u003cp\u003e\n  To sort the items by price range you'll need to loop through the dictionary\n  and add the names of items that have a price within the specified range to a\n  list. You can then return that list.\n\u003c/p\u003e"],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["python"],"name":"Inventory Class","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Write an \u003cspan\u003eInventory\u003c/span\u003e class, as defined below, that handles the\n    management of inventory for a company. All instances of this class should be\n    initialized by passing an integer value named \u003cspan\u003emax_capacity\u003c/span\u003e that\n    indicates the maximum number of items that can be stored in inventory. Your\n    \u003cspan\u003eInventory\u003c/span\u003e class will need to store items that are represented\n    by a \u003cspan\u003ename\u003c/span\u003e, \u003cspan\u003eprice\u003c/span\u003e and \u003cspan\u003equantity\u003c/span\u003e.\n  \u003c/p\u003e\n  \u003cp\u003eYour class should implement the following methods.\u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003eadd_item(name, price, quantity)\u003c/span\u003e: This method should add an\n      item to inventory and return \u003cspan\u003eTrue\u003c/span\u003e if it was successfully\n      added. If adding an item results in the inventory being over capacity your\n      method should return \u003cspan\u003eFalse\u003c/span\u003e and omit adding this item to the\n      inventory. Additionally, if an item with the passed\n      \u003cspan\u003ename\u003c/span\u003e already exists in inventory this method should return\n      \u003cspan\u003eFalse\u003c/span\u003e to indicate the item could not be added.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003edelete_item(name)\u003c/span\u003e: This method should delete an item from\n      inventory and return \u003cspan\u003eTrue\u003c/span\u003e if the item was successfully\n      deleted. If there is no item with the passed \u003cspan\u003ename\u003c/span\u003e this method\n      should return \u003cspan\u003eFalse\u003c/span\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003eget_most_stocked_item()\u003c/span\u003e: This method should return the name\n      of the item that has the highest quantity in the inventory, and return\n      \u003cspan\u003eNone\u003c/span\u003e if there are no items in the inventory. You may assume\n      there will always be exactly one item with the largest quantity, except\n      for the case where the inventory is empty.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003eget_items_in_price_range(min_price, max_price)\u003c/span\u003e: This method\n      should return a list of the names of items that have a price within the\n      specified range (inclusively).\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    Note: you may assume all input/arguments to your class will be valid and the\n    correct types. For example, the \u003cspan\u003emax_capacity\u003c/span\u003e will always be\n    greater than or equal to \u003cspan\u003e0\u003c/span\u003e and a valid integer.\n  \u003c/p\u003e\n  \u003cp\u003e\n    See below for an example of how the \u003cspan\u003eInventory\u003c/span\u003e class should\n    behave.\n  \u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"code-wrapper prism\"\u003e\n  \u003cpre class=\"line-numbers\"\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e i = Inventory(4)\n\u003e\u003e\u003e i.add_item('Chocolate', 4.99, 1)\nTrue\n\u003e\u003e\u003e i.add_item('Cereal', 6.99, 1)\nTrue\n\u003e\u003e\u003e i.add_item('Milk', 3.99, 2)\nTrue\n\u003e\u003e\u003e i.add_item('Butter', 2.99, 1)\nFalse\n\u003e\u003e\u003e i.delete_item('Bread')\nFalse\n\u003e\u003e\u003e i.delete_item('Cereal')\nTrue        \n\u003e\u003e\u003e i.get_items_in_price_range(4.50, 6.50)\n['Chocolate']\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e","releaseDate":"0001-01-01T00:00:00Z","resources":{"python":{"language":"python","sandboxCode":"# This suite of tests is written to run against your code\n# so that we can check its correctness.\n\nimport unittest\n\nfrom program import Inventory\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        inventory = Inventory(0)\n        self.assertFalse(inventory.add_item('Chocolate', 4.99, 1))\n\n    def test_case_2(self):\n        inventory = Inventory(3)\n        self.assertFalse(inventory.add_item('Chocolate', 4.99, 4))\n\n    def test_case_3(self):\n        inventory = Inventory(3)\n        self.assertTrue(inventory.add_item('Chocolate', 4.99, 1))\n        self.assertTrue(inventory.add_item('Butter', 4.99, 1))\n        self.assertFalse(inventory.add_item('Butter', 4.99, 1))\n        self.assertFalse(inventory.add_item('Bread', 4.99, 2))\n\n    def test_case_4(self):\n        inventory = Inventory(4)\n        self.assertTrue(inventory.add_item('Chocolate', 4.99, 1))\n        self.assertTrue(inventory.add_item('Butter', 4.99, 1))\n        self.assertTrue(inventory.add_item('Bread', 4.99, 2))\n        self.assertEqual('Bread', inventory.get_most_stocked_item())\n\n    def test_case_5(self):\n        inventory = Inventory(4)\n        self.assertTrue(inventory.add_item('Chocolate', 4.99, 4))\n        self.assertTrue(inventory.delete_item('Chocolate'))\n        self.assertFalse(inventory.delete_item('Chocolate'))\n        self.assertFalse(inventory.delete_item('Bread'))\n        self.assertTrue(inventory.add_item('Chocolate', 4.99, 2))\n        self.assertTrue(inventory.add_item('Bread', 4.99, 2))\n        self.assertIn(inventory.get_most_stocked_item(), ('Chocolate', 'Bread'))\n\n    def test_case_6(self):\n        inventory = Inventory(5)\n        self.assertIsNone(inventory.get_most_stocked_item())\n        self.assertEqual([], inventory.get_items_in_price_range(1, 10))\n\n    def test_case_7(self):\n        inventory = Inventory(5)\n        self.assertTrue(inventory.add_item('Chocolate', 4.99, 1))\n        self.assertTrue(inventory.add_item('Bread', 3.99, 1))\n        self.assertTrue(inventory.add_item('Milk', 5.99, 3))\n        self.assertEqual(sorted(['Chocolate', 'Milk', 'Bread']), sorted(inventory.get_items_in_price_range(1, 10)))\n\n    def test_case_8(self):\n        max_capacity = 4\n        inventory = Inventory(max_capacity)\n        self.assertEqual(inventory.add_item('Chocolate', 4.99, 1), True)\n        self.assertEqual(inventory.add_item('Cereal', 6.99, 1), True)\n        self.assertEqual(inventory.add_item('Milk', 3.99, 2), True)\n        self.assertEqual(inventory.add_item('Butter', 2.99, 1), False)\n        self.assertEqual(inventory.delete_item('Bread'), False)\n        self.assertEqual(inventory.delete_item('Cereal'), True)\n        self.assertEqual(inventory.get_items_in_price_range(4.50, 6.50), ['Chocolate'])\n","solutions":["# Copyright Â© 2022 AlgoExpert LLC. All rights reserved.\n\nclass Inventory:\n    def __init__(self, max_capacity):\n        self.max_capacity = max_capacity\n        self.items = {}\n        self.item_count = 0\n\n    def add_item(self, name, price, quantity):\n        if name in self.items:\n            return False\n\n        if self.item_count + quantity \u003e self.max_capacity:\n            return False\n\n        self.items[name] = {\"name\": name, \"price\": price, \"quantity\": quantity}\n        self.item_count += quantity\n        return True\n\n    def delete_item(self, name):\n        if name not in self.items:\n            return False\n\n        self.item_count -= self.items[name][\"quantity\"]\n        del self.items[name]\n        return True\n\n    def get_items_in_price_range(self, min_price, max_price):\n        item_names = []\n\n        for item in self.items.values():\n            name = item[\"name\"]\n            price = item[\"price\"]\n\n            if min_price \u003c= price \u003c= max_price:\n                item_names.append(name)\n\n        return item_names\n\n    def get_most_stocked_item(self):\n        most_stocked_item_name = None\n        largest_quantity = 0\n\n        for item in self.items.values():\n            name = item[\"name\"]\n            quantity = item[\"quantity\"]\n\n            if quantity \u003e largest_quantity:\n                most_stocked_item_name = name\n                largest_quantity = quantity\n\n        return most_stocked_item_name\n"],"solutionsDisabled":false,"startingCode":"class Inventory:\n    def __init__(self, max_capacity):\n        # Write your code here.\n        pass\n\n    def add_item(self, name, price, quantity):\n        # Write your code here.\n        pass\n\n    def delete_item(self, name):\n        # Write your code here.\n        pass\n\n    def get_items_in_price_range(self, min_price, max_price):\n        # Write your code here.\n        pass\n\n    def get_most_stocked_item(self):\n        # Write your code here.\n        pass","unitTests":"import unittest\n\nfrom program import Inventory\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        inventory = Inventory(0)\n        self.assertFalse(inventory.add_item('Chocolate', 4.99, 1))\n\n    def test_case_2(self):\n        inventory = Inventory(3)\n        self.assertFalse(inventory.add_item('Chocolate', 4.99, 4))\n\n    def test_case_3(self):\n        inventory = Inventory(3)\n        self.assertTrue(inventory.add_item('Chocolate', 4.99, 1))\n        self.assertTrue(inventory.add_item('Butter', 4.99, 1))\n        self.assertFalse(inventory.add_item('Butter', 4.99, 1))\n        self.assertFalse(inventory.add_item('Bread', 4.99, 2))\n\n    def test_case_4(self):\n        inventory = Inventory(4)\n        self.assertTrue(inventory.add_item('Chocolate', 4.99, 1))\n        self.assertTrue(inventory.add_item('Butter', 4.99, 1))\n        self.assertTrue(inventory.add_item('Bread', 4.99, 2))\n        self.assertEqual('Bread', inventory.get_most_stocked_item())\n\n    def test_case_5(self):\n        inventory = Inventory(4)\n        self.assertTrue(inventory.add_item('Chocolate', 4.99, 4))\n        self.assertTrue(inventory.delete_item('Chocolate'))\n        self.assertFalse(inventory.delete_item('Chocolate'))\n        self.assertFalse(inventory.delete_item('Bread'))\n        self.assertTrue(inventory.add_item('Chocolate', 4.99, 2))\n        self.assertTrue(inventory.add_item('Bread', 4.99, 2))\n        self.assertIn(inventory.get_most_stocked_item(), ('Chocolate', 'Bread'))\n\n    def test_case_6(self):\n        inventory = Inventory(5)\n        self.assertIsNone(inventory.get_most_stocked_item())\n        self.assertEqual([], inventory.get_items_in_price_range(1, 10))\n\n    def test_case_7(self):\n        inventory = Inventory(5)\n        self.assertTrue(inventory.add_item('Chocolate', 4.99, 1))\n        self.assertTrue(inventory.add_item('Bread', 3.99, 1))\n        self.assertTrue(inventory.add_item('Milk', 5.99, 3))\n        self.assertEqual(sorted(['Chocolate', 'Milk', 'Bread']), sorted(inventory.get_items_in_price_range(1, 10)))\n\n    def test_case_8(self):\n        max_capacity = 4\n        inventory = Inventory(max_capacity)\n        self.assertEqual(inventory.add_item('Chocolate', 4.99, 1), True)\n        self.assertEqual(inventory.add_item('Cereal', 6.99, 1), True)\n        self.assertEqual(inventory.add_item('Milk', 3.99, 2), True)\n        self.assertEqual(inventory.add_item('Butter', 2.99, 1), False)\n        self.assertEqual(inventory.delete_item('Bread'), False)\n        self.assertEqual(inventory.delete_item('Cereal'), True)\n        self.assertEqual(inventory.get_items_in_price_range(4.50, 6.50), ['Chocolate'])\n"}},"spaceTime":"","submissionStatistics":{"correctCount":1465,"failureCount":17352},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"67239960","version":0,"video":{"annotations":[],"codeWalkthroughTime":1475,"duration":12,"instructor":"Tim Ruscica","overviewTime":0,"vimeoId":"642920205"},"visualization":{"inputType":null,"outputType":null}},"difficulty":1,"instructor":"Tim Ruscica","name":"Inventory Class","releaseDate":"0001-01-01T00:00:00Z","type":"CODING_STANDARD","uid":"67239960"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["programmingexpert"]},"category":"ObjectOrientedProgrammingAssessments","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["programmingexpert"]},"assessmentSummary":null,"category":"ObjectOrientedProgrammingAssessments","changelog":[],"customInputVars":[],"difficulty":1,"hints":["\u003cp\u003e\n  When creating a static method there should be no \u003cspan\u003eself\u003c/span\u003e parameter\n  and you should decorate the method with the\n  \u003cspan\u003e@staticmethod\u003c/span\u003e decorator.\n\u003c/p\u003e\n","\n\u003cp\u003e\n  Class variables go before the \u003cspan\u003e__init__\u003c/span\u003e method and inside the body\n  of the class direclty. They can be accessed by using the class name direclty\n  or the \u003cspan\u003eself\u003c/span\u003e parameter if applicable.\n\u003c/p\u003e\n","\n\u003cp\u003e\n  To create a property you need to define a getter and setter method. You can do\n  this using the \u003cspan\u003e@property\u003c/span\u003e decorator above a getter method named\n  \u003cspan\u003ecurrent_temperature\u003c/span\u003e and then\n  \u003cspan\u003e@current_temperature.setter\u003c/span\u003e above the cooresponding setter\n  method. You can also define the getter and setter without decorators and\n  define a class variable named \u003cspan\u003ecurrent_temperature\u003c/span\u003e that is equal\n  to \u003cspan\u003epropery(getter_method, setter_method)\u003c/span\u003e.\n\u003c/p\u003e\n","\n\u003cp\u003e\n  To determine if a value is a \u003cspan\u003efloat\u003c/span\u003e or an \u003cspan\u003eint\u003c/span\u003e you can\n  use the built-in function \u003cspan\u003eisinstance(variable, type)\u003c/span\u003e. For\n  example, \u003cspan\u003eisinstance(1, int)\u003c/span\u003e returns \u003cspan\u003eTrue\u003c/span\u003e.\n\u003c/p\u003e"],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["python"],"name":"Student Class","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Write a \u003cspan\u003eStudent\u003c/span\u003e class, as defined below, that keeps track of\n    all created students.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Your class should implement the following methods, class variables and\n    properties:\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003eAn instance attribute called \u003cspan\u003ename\u003c/span\u003e.\u003c/li\u003e\n    \u003cli\u003e\n      A property called \u003cspan\u003egrade\u003c/span\u003e that returns the grade of that\n      student. Trying to set the grade should raise a \u003cspan\u003eValueError\u003c/span\u003e if\n      the new grade is not a number between \u003cspan\u003e0\u003c/span\u003e and \u003cspan\u003e100\u003c/span\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n      A static method called \u003cspan\u003ecalculate_average_grade(students)\u003c/span\u003e that\n      accepts a list of \u003cspan\u003eStudent\u003c/span\u003e objects and returns the average\n      grade for those students. If there are no students in the list, it should\n      return \u003cspan\u003e-1\u003c/span\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n      A class variable called \u003cspan\u003eall_students\u003c/span\u003e that stores all of the\n      student objects that have been created in a list.\n    \u003c/li\u003e\n    \u003cli\u003e\n      A class method named \u003cspan\u003eget_average_grade()\u003c/span\u003e which returns the\n      average grade of all created students.\n    \u003c/li\u003e\n    \u003cli\u003e\n      A class method named \u003cspan\u003eget_best_student()\u003c/span\u003e which returns the\n      student object with the best grade out of all the currently created\n      students. If there are no students created this method should return\n      \u003cspan\u003eNone\u003c/span\u003e. You may assume there will always be one student with\n      the best grade, except in the case where there are no students created.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    See below for an example of the behavior of the\n    \u003cspan\u003eStudent\u003c/span\u003e class.\n  \u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"code-wrapper prism\"\u003e\n  \u003cpre\n    class=\"line-numbers\"\n  \u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e Student.get_average_grade()\n-1\n\u003e\u003e\u003e student1 = Student(\"Antoine\", 75)\n\u003e\u003e\u003e student1.name\n\"Antoine\"\n\u003e\u003e\u003e student1.grade\n75\n\u003e\u003e\u003e student1.grade = 150\nTraceback (most recent call last):\n  File \"\u0026lt;stdin\u0026gt;\", line 1, in \u0026lt;module\u0026gt;\nValueError: New grade not in the accepted range of [0-100].\n\u003e\u003e\u003e student1 == Student.get_best_student()\nTrue\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e","releaseDate":"0001-01-01T00:00:00Z","resources":{"python":{"language":"python","sandboxCode":"# This suite of tests is written to run against your code\n# so that we can check its correctness.\n\nimport unittest\n\nfrom program import Student\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        average_grade_without_students = Student.get_average_grade()\n        self.assertEqual(average_grade_without_students, -1)\n        self.assertEqual(Student.get_best_student(), None)\n\n    def test_case_2(self):\n        student1 = Student(\"Antoine\", 75)\n        average = Student.get_average_grade()\n        best_student = Student.get_best_student()\n        self.assertEqual(average, 75)\n        self.assertEqual(best_student, student1)\n        self.assertEqual(\"Antoine\", best_student.name)\n\n    def test_case_3(self):\n        student2 = Student(\"Tim\", 81)\n        average = Student.get_average_grade()\n        best_student = Student.get_best_student()\n        self.assertEqual(average, 78)\n        self.assertEqual(best_student, student2)\n        self.assertEqual(\"Tim\", best_student.name)\n\n    def test_case_4(self):\n        student3 = Student(\"Clement\", 30)\n        average = Student.get_average_grade()\n        best_student = Student.get_best_student()\n        self.assertEqual(average, 62)\n        self.assertEqual(\"Tim\", best_student.name)\n\n    def test_case_5(self):\n        best_student = Student.get_best_student()\n        best_student.grade = best_student.grade - 10\n        new_best_student = Student.get_best_student()\n        self.assertEqual(\"Antoine\", new_best_student.name)\n\n    def test_case_6(self):\n        best_student = Student.get_best_student()\n        with self.assertRaises(ValueError):\n            best_student.grade = 150\n\n    def test_case_7(self):\n        students = [\n            Student(\"Simon\", 55),\n            Student(\"Alex\", 69),\n            Student(\"James\", 8),\n        ]\n        self.assertEqual(44, Student.calculate_average_grade(students))\n","solutions":["# Copyright Â© 2022 AlgoExpert LLC. All rights reserved.\n\nclass Student:\n    all_students = []\n\n    def __init__(self, name, grade):\n        self.name = name\n        self._grade = grade\n        Student.all_students.append(self)\n\n    @property\n    def grade(self):\n        return self._grade\n\n    @grade.setter\n    def grade(self, new_grade):\n        if new_grade \u003c 0 or new_grade \u003e 100:\n            raise ValueError(\"New grade not in the accepted range of [0-100].\")\n        self._grade = new_grade\n\n    @classmethod\n    def get_best_student(cls):\n        best_student = None\n        for student in cls.all_students:\n            if best_student == None or best_student.grade \u003c student.grade:\n                best_student = student\n        return best_student\n\n    @classmethod\n    def get_average_grade(cls):\n        return cls.calculate_average_grade(cls.all_students)\n\n    @staticmethod\n    def calculate_average_grade(students):\n        if len(students) == 0:\n            return -1\n\n        total = 0\n        for student in students:\n            total += student.grade\n        return total / len(students)\n"],"solutionsDisabled":false,"startingCode":"class Student:\n    # Write your code here.\n\n    def __init__(self, name, grade):\n        # Write your code here.\n        pass\n\n    # Write your code here.\n","unitTests":"import unittest\n\nfrom program import Student\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        average_grade_without_students = Student.get_average_grade()\n        self.assertEqual(average_grade_without_students, -1)\n        self.assertEqual(Student.get_best_student(), None)\n\n    def test_case_2(self):\n        student1 = Student(\"Antoine\", 75)\n        average = Student.get_average_grade()\n        best_student = Student.get_best_student()\n        self.assertEqual(average, 75)\n        self.assertEqual(best_student, student1)\n        self.assertEqual(\"Antoine\", best_student.name)\n\n    def test_case_3(self):\n        student2 = Student(\"Tim\", 81)\n        average = Student.get_average_grade()\n        best_student = Student.get_best_student()\n        self.assertEqual(average, 78)\n        self.assertEqual(best_student, student2)\n        self.assertEqual(\"Tim\", best_student.name)\n\n    def test_case_4(self):\n        student3 = Student(\"Clement\", 30)\n        average = Student.get_average_grade()\n        best_student = Student.get_best_student()\n        self.assertEqual(average, 62)\n        self.assertEqual(\"Tim\", best_student.name)\n\n    def test_case_5(self):\n        best_student = Student.get_best_student()\n        best_student.grade = best_student.grade - 10\n        new_best_student = Student.get_best_student()\n        self.assertEqual(\"Antoine\", new_best_student.name)\n\n    def test_case_6(self):\n        best_student = Student.get_best_student()\n        with self.assertRaises(ValueError):\n            best_student.grade = 150\n\n    def test_case_7(self):\n        students = [\n            Student(\"Simon\", 55),\n            Student(\"Alex\", 69),\n            Student(\"James\", 8),\n        ]\n        self.assertEqual(44, Student.calculate_average_grade(students))\n"}},"spaceTime":"","submissionStatistics":{"correctCount":1392,"failureCount":12209},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"17952219","version":0,"video":{"annotations":[],"codeWalkthroughTime":1475,"duration":10,"instructor":"Tim Ruscica","overviewTime":0,"vimeoId":"642920109"},"visualization":{"inputType":null,"outputType":null}},"difficulty":1,"instructor":"Tim Ruscica","name":"Student Class","releaseDate":"0001-01-01T00:00:00Z","type":"CODING_STANDARD","uid":"17952219"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["programmingexpert"]},"category":"ObjectOrientedProgrammingAssessments","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["programmingexpert"]},"assessmentSummary":null,"category":"ObjectOrientedProgrammingAssessments","changelog":[],"customInputVars":[],"difficulty":1,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["python"],"name":"Geometry Inheritance","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Create 4 classes: \u003cspan\u003ePolygon\u003c/span\u003e, \u003cspan\u003eTriangle\u003c/span\u003e,\n    \u003cspan\u003eRectangle\u003c/span\u003e and \u003cspan\u003eSquare\u003c/span\u003e. The\n    \u003cspan\u003eTriangle\u003c/span\u003e and \u003cspan\u003eRectangle\u003c/span\u003e class should be subclasses\n    of \u003cspan\u003ePolygon\u003c/span\u003e, and \u003cspan\u003eSquare\u003c/span\u003e should be a subclass of\n    \u003cspan\u003eRectangle\u003c/span\u003e.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Your \u003cspan\u003ePolygon\u003c/span\u003e class should raise a\n    \u003cspan\u003eNotImplementedError\u003c/span\u003e when the \u003cspan\u003eget_area()\u003c/span\u003e and\n    \u003cspan\u003eget_sides()\u003c/span\u003e methods are called. However, it should correctly\n    return the perimeter of the polygon when \u003cspan\u003eget_perimeter()\u003c/span\u003e is\n    called. Treat the \u003cspan\u003ePolygon\u003c/span\u003e class as an \u003cb\u003eabstract\u003c/b\u003e class.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Your \u003cspan\u003eTriangle\u003c/span\u003e class should have a constructor that takes in 3\n    arguments, which will be the lengths of the 3 sides of the triangle. You may\n    assume the sides passed to the constructor will always form a valid\n    triangle.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Your \u003cspan\u003eRectangle\u003c/span\u003e class should have a constructor that takes in 2\n    arguments, which will be the \u003cspan\u003ewidth\u003c/span\u003e and \u003cspan\u003eheight\u003c/span\u003e of\n    the \u003cspan\u003eRectangle\u003c/span\u003e.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Your \u003cspan\u003eSquare\u003c/span\u003e class should have a constructor that takes in 1\n    argument, which will be the length of each side of the \u003cspan\u003eSquare\u003c/span\u003e.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Your \u003cspan\u003eTriangle\u003c/span\u003e and \u003cspan\u003eRectangle\u003c/span\u003e classes should both\n    implement the following methods:\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003eget_sides()\u003c/span\u003e: This method returns a list containing the\n      lengths of the sides of the shape.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003eget_area()\u003c/span\u003e: This method returns the area of the polygon.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    Your \u003cspan\u003eSquare\u003c/span\u003e class should only have an implementation for its\n    constructor, and rely on the \u003cspan\u003eRectangle\u003c/span\u003e superclass for\n    implementations of \u003cspan\u003eget_sides()\u003c/span\u003e and \u003cspan\u003eget_area()\u003c/span\u003e.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Note: To calculate the area of a triangle given three side lengths\n    (\u003cspan\u003ex\u003c/span\u003e,\n    \u003cspan\u003ey\u003c/span\u003e and \u003cspan\u003ez\u003c/span\u003e) you can use the following formula. First\n    calculate the semi perimeter \u003cspan\u003es\u003c/span\u003e using:\n    \u003cspan\u003es = (x + y + z) / 2\u003c/span\u003e. Then calculate the area\n    \u003cspan\u003eA\u003c/span\u003e using:\n    \u003cspan\u003eA = math.sqrt(s * (s - x) * (s - y) * (s - z))\u003c/span\u003e.\n  \u003c/p\u003e\n  \u003cp\u003eSee below for an example of how these classes should behave.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"code-wrapper prism\"\u003e\n\u003cpre class=\"line-numbers\" \u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e triangle = Triangle(2, 5, 6)\n\u003e\u003e\u003e triangle.get_area()\n4.68\n\u003e\u003e\u003e Square(4).get_perimeter()\n16\n\u003e\u003e\u003e Rectangle(3, 5).get_sides()\n[3, 5, 3, 5]\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e","releaseDate":"0001-01-01T00:00:00Z","resources":{"python":{"language":"python","sandboxCode":"# This suite of tests is written to run against your code\n# so that we can check its correctness.\n\nimport unittest\n\nfrom program import Polygon, Triangle, Rectangle, Square\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        with self.assertRaises(NotImplementedError):\n            Polygon().get_sides()\n        with self.assertRaises(NotImplementedError):\n            Polygon().get_area()\n        with self.assertRaises(NotImplementedError):\n            Polygon().get_perimeter()\n\n    def test_case_2(self):\n        triangle = Triangle(1, 1, 1)\n        self.assertEqual(3, triangle.get_perimeter())\n        rect = Rectangle(2, 3)\n        self.assertEqual(10, rect.get_perimeter())\n        square = Square(3)\n        self.assertEqual(12, square.get_perimeter())\n\n    def test_case_3(self):\n        triangle = Triangle(1, 5, 6)\n        self.assertEqual([1, 5, 6], sorted(triangle.get_sides()))\n        rect = Rectangle(2, 3)\n        self.assertEqual([2, 2, 3, 3], sorted(rect.get_sides()))\n        square = Square(3)\n        self.assertEqual([3, 3, 3, 3], sorted(square.get_sides()))\n\n    def test_case_4(self):\n        triangle = Triangle(2, 5, 6)\n        self.assertAlmostEqual(4.68, triangle.get_area(), delta=0.01)\n        rect = Rectangle(2, 3)\n        self.assertEqual(6, rect.get_area())\n        square = Square(5)\n        self.assertEqual(25, square.get_area())\n","solutions":["# Copyright Â© 2022 AlgoExpert LLC. All rights reserved.\n\nimport math\n\n\nclass Polygon:\n    def get_sides(self):\n        raise NotImplementedError\n\n    def get_area(self):\n        raise NotImplementedError\n\n    def get_perimeter(self):\n        return sum(self.get_sides())\n\n\nclass Triangle(Polygon):\n    def __init__(self, side1, side2, side3):\n        self.sides = [side1, side2, side3]\n\n    def get_sides(self):\n        return self.sides\n\n    def get_area(self):\n        side1, side2, side3 = self.sides\n        return get_triangle_area(side1, side2, side3)\n\n\nclass Rectangle(Polygon):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def get_sides(self):\n        return [self.width, self.height, self.width, self.height]\n\n    def get_area(self):\n        return get_rectangle_area(self.width, self.height)\n\n\nclass Square(Rectangle):\n    def __init__(self, side_length):\n        super().__init__(side_length, side_length)\n\n\ndef get_triangle_area(side1, side2, side3):\n    semi_perimeter = (side1 + side2 + side3) / 2\n    return math.sqrt(\n        semi_perimeter * \n        (semi_perimeter - side1) * \n        (semi_perimeter - side2) * \n        (semi_perimeter - side3)\n    )\n\n\ndef get_rectangle_area(width, height):\n    return width * height\n"],"solutionsDisabled":false,"startingCode":"import math\n\n\nclass Polygon:\n    # Write your code here.\n    pass\n\n\nclass Triangle(Polygon):\n    # Write your code here.\n    pass\n\n\nclass Rectangle(Polygon):\n    # Write your code here.\n    pass\n\n\nclass Square(Rectangle):\n    # Write your code here.\n    pass\n\n\n# Use this function in your solution.\ndef get_triangle_area(side1, side2, side3):\n    semi_perimeter = (side1 + side2 + side3) / 2\n    return math.sqrt(\n        semi_perimeter *\n        (semi_perimeter - side1) *\n        (semi_perimeter - side2) *\n        (semi_perimeter - side3)\n    )\n\n\n# Use this function in your solution.\ndef get_rectangle_area(width, height):\n    return width * height\n","unitTests":"import unittest\n\nfrom program import Polygon, Triangle, Rectangle, Square\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        with self.assertRaises(NotImplementedError):\n            Polygon().get_sides()\n        with self.assertRaises(NotImplementedError):\n            Polygon().get_area()\n        with self.assertRaises(NotImplementedError):\n            Polygon().get_perimeter()\n\n    def test_case_2(self):\n        triangle = Triangle(1, 1, 1)\n        self.assertEqual(3, triangle.get_perimeter())\n        rect = Rectangle(2, 3)\n        self.assertEqual(10, rect.get_perimeter())\n        square = Square(3)\n        self.assertEqual(12, square.get_perimeter())\n\n    def test_case_3(self):\n        triangle = Triangle(1, 5, 6)\n        self.assertEqual([1, 5, 6], sorted(triangle.get_sides()))\n        rect = Rectangle(2, 3)\n        self.assertEqual([2, 2, 3, 3], sorted(rect.get_sides()))\n        square = Square(3)\n        self.assertEqual([3, 3, 3, 3], sorted(square.get_sides()))\n\n    def test_case_4(self):\n        triangle = Triangle(2, 5, 6)\n        self.assertAlmostEqual(4.68, triangle.get_area(), delta=0.01)\n        rect = Rectangle(2, 3)\n        self.assertEqual(6, rect.get_area())\n        square = Square(5)\n        self.assertEqual(25, square.get_area())\n"}},"spaceTime":"","submissionStatistics":{"correctCount":1347,"failureCount":6873},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"9680746","version":0,"video":{"annotations":[],"codeWalkthroughTime":1475,"duration":9,"instructor":"Tim Ruscica","overviewTime":0,"vimeoId":"642920081"},"visualization":{"inputType":null,"outputType":null}},"difficulty":1,"instructor":"Tim Ruscica","name":"Geometry Inheritance","releaseDate":"0001-01-01T00:00:00Z","type":"CODING_STANDARD","uid":"9680746"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["programmingexpert"]},"category":"ObjectOrientedProgrammingAssessments","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["programmingexpert"]},"assessmentSummary":null,"category":"ObjectOrientedProgrammingAssessments","changelog":[],"customInputVars":[],"difficulty":1,"hints":["\u003cp\u003e\n  It may be helpful to write a static method that can determine if a card is\n  valid. This may help you avoid repeating the same code in multiple places.\n\u003c/p\u003e\n","\n\u003cp\u003e\n  When checking the value and suit of a card remember that cards with value\n  \u003cspan\u003e\"10\"\u003c/span\u003e exist. This means you cannot simply say\n  \u003cspan\u003ecard_value = card[0]\u003c/span\u003e or \u003cspan\u003ecard_suit = card[1]\u003c/span\u003e.\n\u003c/p\u003e\n","\n\u003cp\u003e\n  To sort the cards by suit you can create \u003cspan\u003e4\u003c/span\u003e lists, one to store\n  each suit, and place cards from the deck into their corresponding lists. Once\n  all the lists are filled you can combine them together to generate the\n  sorted deck. Once you've done this simply override the existing deck with your\n  newly sorted deck.\n\u003c/p\u003e"],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["python"],"name":"Deck Class","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Create a \u003cspan\u003eDeck\u003c/span\u003e class that represents a deck of\n    \u003cspan\u003e52\u003c/span\u003e playing cards. The \u003cspan\u003eDeck\u003c/span\u003e should maintain which\n    cards are currently in the deck and never contain duplicated cards. Cards\n    should be represented by a string containing their value\n    \u003cspan\u003e(2 - 10, J, Q, K, A)\u003c/span\u003e followed by their suit\n    \u003cspan\u003e(D, H, C, S)\u003c/span\u003e. For example, the jack of clubs would be\n    represented by \u003cspan\u003e\"JC\"\u003c/span\u003e and the three of hearts would be\n    represented by \u003cspan\u003e\"3H\"\u003c/span\u003e.\n  \u003c/p\u003e\n  \u003cp\u003eYour \u003cspan\u003eDeck\u003c/span\u003e class should implement the following methods:\u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003eshuffle()\u003c/span\u003e: This method shuffles the cards randomly, in place.\n      You may use the \u003cspan\u003erandom.shuffle()\u003c/span\u003e method to help you do this.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003edeal(n)\u003c/span\u003e: This method removes and returns the last\n      \u003cspan\u003en\u003c/span\u003e cards from the deck in a list. If the deck does not contain\n      enough cards it returns all the cards in the deck.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003esort_by_suit()\u003c/span\u003e: This method sorts the cards by suit, placing\n      all the hearts first, diamonds second, clubs third and spades last. The\n      order within each suit (i.e. the card values) does not matter. This method\n      should sort the cards in place, it does not return anything.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003econtains(card)\u003c/span\u003e: This method returns \u003cspan\u003eTrue\u003c/span\u003e if the\n      given card exists in the deck and \u003cspan\u003eFalse\u003c/span\u003e otherwise.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003ecopy()\u003c/span\u003e: This method returns a new \u003cspan\u003eDeck\u003c/span\u003e object\n      that is a copy of the current deck. Any modifications made to the new\n      \u003cspan\u003eDeck\u003c/span\u003e object should not affect the \u003cspan\u003eDeck\u003c/span\u003e object\n      that was copied.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003eget_cards()\u003c/span\u003e: This method returns all the cards in the deck in\n      a list. Any modifications to the returned list should not change the\n      \u003cspan\u003eDeck\u003c/span\u003e object.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003e__len__()\u003c/span\u003e: This method returns the number of the cards in the\n      \u003cspan\u003eDeck\u003c/span\u003e.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    Your deck should always start with exactly \u003cspan\u003e52\u003c/span\u003e cards that are\n    distributed across \u003cspan\u003e4\u003c/span\u003e suits and \u003cspan\u003e13\u003c/span\u003e values where\n    there are no duplicate cards.\n  \u003c/p\u003e\n  \u003cp\u003e\n    See below for an example of how the \u003cspan\u003eDeck\u003c/span\u003e class should behave.\n  \u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"code-wrapper prism\"\u003e\n  \u003cpre class=\"line-numbers\"\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e d = Deck()\n\u003e\u003e\u003e d.shuffle()\n\u003e\u003e\u003e d.deal(3)\n[\"AS\", \"2H\", \"4D\"]\n\u003e\u003e\u003e d.contains(\"4D\")\nFalse\n\u003e\u003e\u003e d.sort_by_suit()\n\u003e\u003e\u003e d.deal(3)\n['2S', '5S', 'JS']\n\u003e\u003e\u003e len(d)\n46\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e","releaseDate":"0001-01-01T00:00:00Z","resources":{"python":{"language":"python","sandboxCode":"# This suite of tests is written to run against your code\n# so that we can check its correctness.\n\nimport unittest\n\nfrom program import Deck\n\n\nvalid_values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\nvalid_suits = ['H', 'D', 'C', 'S']\nvalid_cards = [f'{value}{suit}' for suit in valid_suits for value in valid_values]\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        deck1 = Deck()\n        deck2 = Deck()\n        deck1.shuffle()\n        deck2.shuffle()\n        self.assertNotEqual(deck1.get_cards(), deck2.get_cards())\n\n    def test_case_2(self):\n        deck1 = Deck()\n        cards = deck1.get_cards()\n        self.assertEqual(52, len(cards))\n        self.assertEqual(52, len(deck1))\n        for card in cards:\n            self.assertIn(card, valid_cards)\n\n    def test_case_3(self):\n        deck1 = Deck()\n        for card in valid_cards:\n            self.assertTrue(deck1.contains(card))\n\n    def test_case_4(self):\n        deck1 = Deck()\n        deck2 = deck1.copy()\n        self.assertEqual(deck1.get_cards(), deck2.get_cards())\n        deck1.shuffle()\n        self.assertNotEqual(deck1.get_cards(), deck2.get_cards())\n\n    def test_case_5(self):\n        deck1 = Deck()\n        deck1.shuffle()\n        cards = deck1.deal(1)\n        self.assertEqual(1, len(cards))\n        card = cards[0]\n        self.assertFalse(deck1.contains(card))\n\n    def test_case_6(self):\n        deck1 = Deck()\n        deck1.shuffle()\n        deck1.sort_by_suit()\n        for (i, card) in enumerate(deck1.get_cards()):\n            suit = card[len(card)-1]\n            if i \u003c 13:\n                self.assertEqual('H', suit)\n            elif i \u003c 26:\n                self.assertEqual('D', suit)\n            elif i \u003c 39:\n                self.assertEqual('C', suit)\n            else:\n                self.assertEqual('S', suit)\n\n    def test_case_7(self):\n        deck1 = Deck()\n        cards_seen = set([])\n        for i in range(52):\n            cards = deck1.deal(1)\n            self.assertEqual(1, len(cards))\n            card = cards[0]\n            self.assertNotIn(card, cards_seen)\n            cards_seen.add(cards[0])\n\n    def test_case_8(self):\n        deck1 = Deck()\n        for i in range(10):\n            cards = deck1.deal(5)\n            self.assertEqual(5, len(cards))\n        cards = deck1.deal(5)\n        self.assertEqual(2, len(cards))\n\n    def test_case_9(self):\n        deck1 = Deck()\n        deck1.shuffle()\n        cards = deck1.get_cards()\n        cards[0] = 'FAKE CARD'\n        self.assertNotIn('FAKE CARD', deck1.get_cards())\n","solutions":["# Copyright Â© 2022 AlgoExpert LLC. All rights reserved.\n\nimport random\n\n\nclass Deck:\n    suits = [\"H\", \"D\", \"C\", \"S\"]\n    values = [str(i) for i in range(2, 11)] + [\"J\", \"Q\", \"K\", \"A\"]\n\n    def __init__(self):\n        self.cards = []\n        self.fill_deck()\n\n    def fill_deck(self):\n        for suit in Deck.suits:\n            for value in Deck.values:\n                card = value + suit\n                self.cards.append(card)\n\n    def shuffle(self):\n        random.shuffle(self.cards)\n\n    def deal(self, n):\n        dealt_cards = []\n\n        for i in range(n):\n            if len(self.cards) == 0:\n                break\n\n            card = self.cards.pop()\n            dealt_cards.append(card)\n\n        return dealt_cards\n\n    def sort_by_suit(self):\n        cards_by_suit = {\"H\": [], \"D\": [], \"C\": [], \"S\": []}\n\n        for card in self.cards:\n            suit = card[-1]\n            cards_by_suit[suit].append(card)\n\n        self.cards = (\n            cards_by_suit[\"H\"] +\n            cards_by_suit[\"D\"] +\n            cards_by_suit[\"C\"] +\n            cards_by_suit[\"S\"]\n        )\n\n    def contains(self, card):\n        return card in self.cards\n\n    def copy(self):\n        new_deck = Deck()\n        new_deck.cards = self.cards[:]\n        return new_deck\n\n    def get_cards(self):\n        return self.cards[:]\n\n    def __len__(self):\n        return len(self.cards)\n"],"solutionsDisabled":false,"startingCode":"class Deck:\n    # Write your code here.\n    pass\n","unitTests":"import unittest\n\nfrom program import Deck\n\n\nvalid_values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\nvalid_suits = ['H', 'D', 'C', 'S']\nvalid_cards = [f'{value}{suit}' for suit in valid_suits for value in valid_values]\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        deck1 = Deck()\n        deck2 = Deck()\n        deck1.shuffle()\n        deck2.shuffle()\n        self.assertNotEqual(deck1.get_cards(), deck2.get_cards())\n\n    def test_case_2(self):\n        deck1 = Deck()\n        cards = deck1.get_cards()\n        self.assertEqual(52, len(cards))\n        self.assertEqual(52, len(deck1))\n        for card in cards:\n            self.assertIn(card, valid_cards)\n\n    def test_case_3(self):\n        deck1 = Deck()\n        for card in valid_cards:\n            self.assertTrue(deck1.contains(card))\n\n    def test_case_4(self):\n        deck1 = Deck()\n        deck2 = deck1.copy()\n        self.assertEqual(deck1.get_cards(), deck2.get_cards())\n        deck1.shuffle()\n        self.assertNotEqual(deck1.get_cards(), deck2.get_cards())\n\n    def test_case_5(self):\n        deck1 = Deck()\n        deck1.shuffle()\n        cards = deck1.deal(1)\n        self.assertEqual(1, len(cards))\n        card = cards[0]\n        self.assertFalse(deck1.contains(card))\n\n    def test_case_6(self):\n        deck1 = Deck()\n        deck1.shuffle()\n        deck1.sort_by_suit()\n        for (i, card) in enumerate(deck1.get_cards()):\n            suit = card[len(card)-1]\n            if i \u003c 13:\n                self.assertEqual('H', suit)\n            elif i \u003c 26:\n                self.assertEqual('D', suit)\n            elif i \u003c 39:\n                self.assertEqual('C', suit)\n            else:\n                self.assertEqual('S', suit)\n\n    def test_case_7(self):\n        deck1 = Deck()\n        cards_seen = set([])\n        for i in range(52):\n            cards = deck1.deal(1)\n            self.assertEqual(1, len(cards))\n            card = cards[0]\n            self.assertNotIn(card, cards_seen)\n            cards_seen.add(cards[0])\n\n    def test_case_8(self):\n        deck1 = Deck()\n        for i in range(10):\n            cards = deck1.deal(5)\n            self.assertEqual(5, len(cards))\n        cards = deck1.deal(5)\n        self.assertEqual(2, len(cards))\n\n    def test_case_9(self):\n        deck1 = Deck()\n        deck1.shuffle()\n        cards = deck1.get_cards()\n        cards[0] = 'FAKE CARD'\n        self.assertNotIn('FAKE CARD', deck1.get_cards())\n"}},"spaceTime":"","submissionStatistics":{"correctCount":1282,"failureCount":11698},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"9680756","version":0,"video":{"annotations":[],"codeWalkthroughTime":1475,"duration":16,"instructor":"Tim Ruscica","overviewTime":0,"vimeoId":"642920064"},"visualization":{"inputType":null,"outputType":null}},"difficulty":1,"instructor":"Tim Ruscica","name":"Deck Class","releaseDate":"0001-01-01T00:00:00Z","type":"CODING_STANDARD","uid":"9680756"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["programmingexpert"]},"category":"ObjectOrientedProgrammingAssessments","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["programmingexpert"]},"assessmentSummary":null,"category":"ObjectOrientedProgrammingAssessments","changelog":[],"customInputVars":[],"difficulty":1,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["python"],"name":"FileSystem Implementation","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    In this question, you need to implement a very simplistic\n    \u003cspan\u003eFileSystem\u003c/span\u003e class that mimics the way that your own computer's\n    \u003cspan\u003eFileSystem\u003c/span\u003e works. A \u003cspan\u003eFileSystem\u003c/span\u003e starts empty with\n    only a root node which will always be a directory.\n  \u003c/p\u003e\n  \u003cp\u003e\n    A \u003cspan\u003eFileSystem\u003c/span\u003e is a tree-like structure composed of nodes, each\n    of which is either a \u003cspan\u003eFile\u003c/span\u003e or \u003cspan\u003eDirectory\u003c/span\u003e.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Files are simplest and only have \u003cspan\u003ename\u003c/span\u003e and\n    \u003cspan\u003econtents\u003c/span\u003e as attributes; which correspond to the name of the\n    file and its contents, respectively. Files also have a\n    \u003cspan\u003ewrite\u003c/span\u003e method, which sets the contents of that file to the\n    argument passed in. Additionally, files override the\n    \u003cspan\u003e__len__\u003c/span\u003e dunder method which returns the number of characters in\n    the contents of that file.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Directories have a \u003cspan\u003ename\u003c/span\u003e and a \u003cspan\u003echildren\u003c/span\u003e attribute.\n    \u003cspan\u003echildren\u003c/span\u003e is a dictionary that stores the name of its children\n    nodes as keys, and the nodes themselves as the values of that dictionary.\n    Directories also have the \u003cspan\u003eadd\u003c/span\u003e and \u003cspan\u003edelete\u003c/span\u003e methods\n    which are used to add or delete nodes from its\n    \u003cspan\u003echildren\u003c/span\u003e dictionary.\n  \u003c/p\u003e\n  \u003cp\u003e\n    For your convenience, the \u003cspan\u003e__str__\u003c/span\u003e methods of each class have\n    been overridden so that you may debug your FileSystem more easily.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Your task is to implement the following methods on the\n    \u003cspan\u003eFileSystem\u003c/span\u003e class:\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003ecreate_directory(path)\u003c/span\u003e: This method should create a\n      \u003cspan\u003eDirectory\u003c/span\u003e inside the \u003cspan\u003eFileSystem\u003c/span\u003e at the location\n      specified. For instance, \u003cspan\u003ecreate_directory(\"/dir1\")\u003c/span\u003e should\n      create a directory as a child of the root of the filesystem called\n      \u003cspan\u003e\"dir1\"\u003c/span\u003e. Running\n      \u003cspan\u003ecreate_directory(\"/dir1/dir2\")\u003c/span\u003e should create another\n      directory, \u003cspan\u003edir2\u003c/span\u003e, inside the one that was just created. If the\n      path is malformed or the operation is impossible, it should raise a\n      \u003cspan\u003eValueError\u003c/span\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003ecreate_file(path, contents)\u003c/span\u003e: This method should create a new\n      file at the desired path, with the contents passed in. If the operation is\n      impossible, it should raise a \u003cspan\u003eValueError\u003c/span\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003eread_file(path)\u003c/span\u003e: This method should return the contents of\n      the file at the path parameter. If no such file exists, it should raise a\n      \u003cspan\u003eValueError\u003c/span\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003edelete_directory_or_file(path)\u003c/span\u003e: This method should delete the\n      node located at \u003cspan\u003epath\u003c/span\u003e. It should work on files and directories\n      alike, and should raise a \u003cspan\u003eValueError\u003c/span\u003e\n      if that file does not exist.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003esize()\u003c/span\u003e: This method should return the number of characters\n      across all files in your filesystem.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003e_find_bottom_node(node_names)\u003c/span\u003e: This is a private helper\n      method of the \u003cspan\u003eFileSystem\u003c/span\u003e class that takes in a list of node\n      names and should traverse the filesystem downwards until the last node in\n      the list. For instance, calling this with\n      \u003cspan\u003e[\"a\", \"b\", \"c\"]\u003c/span\u003e should first look for a node\n      \u003cspan\u003ea\u003c/span\u003e inside the root node of the filesystem, then for a node\n      \u003cspan\u003eb\u003c/span\u003e inside node \u003cspan\u003ea\u003c/span\u003e, and then return the node\n      \u003cspan\u003ec\u003c/span\u003e which should be a child of node \u003cspan\u003eb\u003c/span\u003e.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    Note: for all methods that accept a \u003cspan\u003epath\u003c/span\u003e parameter you will\n    need to first validate that path and then parse it. The\n    \u003cspan\u003epath\u003c/span\u003e will be a string, and from that string you'll need to do\n    one of the following:\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      Obtain the directory object used to create a new directory or file inside\n      of.\n    \u003c/li\u003e\n    \u003cli\u003eObtain the directory object used to delete a directory or file.\u003c/li\u003e\n    \u003cli\u003eObtain the file object to read the contents of.\u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    This is non-trivial because you may need to distinguish between the name of\n    the new node create and the path where this node should be created.\n  \u003c/p\u003e\n  \u003cp\u003eSee below for an example of how these classes should behave.\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"code-wrapper prism\"\u003e\n  \u003cpre class=\"line-numbers\"\u003e\u003ccode class=\"language-python\"\u003e\u003e\u003e\u003e fs = FileSystem()\n\u003e\u003e\u003e fs.create_directory(\"/dir1\")\n\u003e\u003e\u003e fs.create_file(\"/file1.txt\", \"Hello World!\")\n\u003e\u003e\u003e print(fs)\n*** FileSystem ***\n/ (Directory)\n  dir1 (Directory)\n  file1.txt (File) | 12 characters\n***\n\u003e\u003e\u003e fs.delete(\"/file2.txt\")\nValueError: file2.txt does not exist.\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e","releaseDate":"0001-01-01T00:00:00Z","resources":{"python":{"language":"python","sandboxCode":"# This suite of tests is written to run against your code\n# so that we can check its correctness.\n\nimport unittest\n\nfrom program import FileSystem\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        fs = FileSystem()\n        fs.create_directory(\"/dir1\")\n        fs.create_directory(\"/dir2\")\n        fs.create_directory(\"/dir1/dir3\")\n        with self.assertRaises(ValueError):\n            fs.create_directory(\"/dir3/dir4\")\n\n    def test_case_2(self):\n        fs = FileSystem()\n        fs.create_file(\"/tim.txt\", \"Tim is great!\")\n        with self.assertRaises(ValueError):\n            fs.create_file(\"/dir1/simon.txt\", \"ProgrammingExpert is fun!\")\n        self.assertEqual(\"Tim is great!\", fs.read_file(\"/tim.txt\"))\n\n    def test_case_3(self):\n        fs = FileSystem()\n        fs.create_file(\"/tim.txt\", \"12345\")\n        self.assertEqual(fs.size(), 5)\n        fs.create_file(\"/alex.txt\", \"67890\")\n        self.assertEqual(fs.size(), 10)\n\n    def test_case_4(self):\n        fs = FileSystem()\n        fs.create_directory(\"/dir1\")\n        fs.create_directory(\"/dir1/dir2\")\n        fs.create_directory(\"/dir1/dir2/dir3\")\n        fs.create_file(\"/dir1/dir2/file1.txt\", \"1\")\n        fs.create_file(\"/dir1/dir2/dir3/file2.txt\", \"1\")\n        self.assertEqual(fs.size(), 2)\n\n    def test_case_5(self):\n        fs = FileSystem()\n        with self.assertRaises(ValueError):\n            fs.delete_directory_or_file(\"/dir1\")\n        fs.create_directory(\"/dir1\")\n        fs.create_file(\"/dir1/simon.txt\", \"ProgrammingExpert is fun!\")\n        self.assertEqual(25, fs.size())\n        with self.assertRaises(ValueError):\n            fs.delete_directory_or_file(\"/dir2\")\n        fs.delete_directory_or_file(\"/dir1\")\n        self.assertEqual(0, fs.size())\n\n    def test_case_6(self):\n        fs = FileSystem()\n        fs.create_directory(\"/dir1\")\n        fs.create_directory(\"/dir1/dir2\")\n        fs.create_file(\"/dir1/dir2/file1.html\", \"Hello World\")\n        self.assertEqual(11, fs.size())\n        self.assertEqual(\"Hello World\", fs.read_file(\"/dir1/dir2/file1.html\"))\n        fs.delete_directory_or_file(\"/dir1\")\n        self.assertEqual(0, fs.size())\n        with self.assertRaises(ValueError):\n            fs.read_file(\"/dir1/dir2/file1.html\")\n","solutions":["# Copyright Â© 2022 AlgoExpert LLC. All rights reserved.\n\nclass FileSystem:\n    def __init__(self):\n        self.root = Directory(\"/\")\n\n    def create_directory(self, path):\n        FileSystem._validate_path(path)\n\n        path_node_names = path[1:].split(\"/\")\n        middle_node_names = path_node_names[:-1]\n        new_directory_name = path_node_names[-1]\n\n        before_last_node = self._find_bottom_node(middle_node_names)\n        \n        if not isinstance(before_last_node, Directory):\n            raise ValueError(f\"{before_last_node.name} isn't a directory.\")\n        \n        new_directory = Directory(new_directory_name)\n\n        before_last_node.add_node(new_directory)\n\n    def create_file(self, path, contents):\n        FileSystem._validate_path(path)\n\n        path_node_names = path[1:].split(\"/\")\n        middle_node_names = path_node_names[:-1]\n        new_file_name = path_node_names[-1]\n\n        before_last_node = self._find_bottom_node(middle_node_names)\n        \n        if not isinstance(before_last_node, Directory):\n            raise ValueError(f\"{before_last_node.name} isn't a directory.\")\n        \n        new_file = File(new_file_name)\n        new_file.write_contents(contents)\n\n        before_last_node.add_node(new_file)\n\n    def read_file(self, path):\n        FileSystem._validate_path(path)\n\n        path_node_names = path[1:].split(\"/\")\n        middle_node_names = path_node_names[:-1]\n        file_name = path_node_names[-1]\n\n        before_last_node = self._find_bottom_node(middle_node_names)\n        \n        if not isinstance(before_last_node, Directory):\n            raise ValueError(f\"{before_last_node.name} isn't a directory.\")\n\n        if file_name not in before_last_node.children:\n            raise ValueError(f\"File not found: {file_name}.\")\n            \n        return before_last_node.children[file_name].contents\n\n    def delete_directory_or_file(self, path):\n        FileSystem._validate_path(path)\n\n        path_node_names = path[1:].split(\"/\")\n        middle_node_names = path_node_names[:-1]\n        node_to_delete_name = path_node_names[-1]\n\n        before_last_node = self._find_bottom_node(middle_node_names)\n        \n        if not isinstance(before_last_node, Directory):\n            raise ValueError(f\"{before_last_node.name} isn't a directory.\")\n\n        if node_to_delete_name not in before_last_node.children:\n            raise ValueError(f\"Node not found: {node_to_delete_name}.\")\n            \n        before_last_node.delete_node(node_to_delete_name)\n\n    def size(self):\n        size = 0\n        nodes = [self.root]\n        while len(nodes) \u003e 0:\n            current_node = nodes.pop()\n            if isinstance(current_node, Directory):\n                children = list(current_node.children.values())\n                nodes.extend(children)\n                continue\n\n            if isinstance(current_node, File):\n                size += len(current_node)\n\n        return size\n\n    def __str__(self):\n        return f\"*** FileSystem ***\\n\" + self.root.__str__() + \"\\n***\"\n    \n    @staticmethod\n    def _validate_path(path):\n        if not path.startswith(\"/\"):\n            raise ValueError(\"Path should start with `/`.\")\n\n\n    def _find_bottom_node(self, node_names):\n        current_node = self.root\n        for node_name in node_names:\n            if not isinstance(current_node, Directory):\n                raise ValueError(f\"{current_node.name} isn't a directory.\")\n\n            if node_name not in current_node.children:\n                raise ValueError(f\"Node not found: {node_name}.\")\n\n            current_node = current_node.children[node_name]\n            \n        return current_node\n\n\nclass Node:\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return f\"{self.name} ({type(self).__name__})\"\n\n\nclass Directory(Node):\n    def __init__(self, name):\n        super().__init__(name)\n        self.children = {}\n\n    def add_node(self, node):\n        self.children[node.name] = node\n\n    def delete_node(self, name):\n        del self.children[name]\n\n    def __str__(self):\n        string = super().__str__()\n\n        children_strings = []\n        for child in list(self.children.values()):\n            child_string = child.__str__().rstrip()\n            children_strings.append(child_string)\n\n        children_combined_string = indent(\"\\n\".join(children_strings), 2)\n        string += \"\\n\" + children_combined_string.rstrip()\n        return string\n\n\nclass File(Node):\n    def __init__(self, name):\n        super().__init__(name)\n        self.contents = \"\"\n\n    def write_contents(self, contents):\n        self.contents = contents\n\n    def __len__(self):\n        return len(self.contents)\n\n    def __str__(self):\n        return super().__str__() + f\" | {len(self)} characters\"\n\n\ndef indent(string, number_of_spaces):\n    spaces = \" \" * number_of_spaces\n    lines = string.split(\"\\n\")\n    indented_lines = [spaces + line for line in lines]\n    return \"\\n\".join(indented_lines)\n","# Copyright Â© 2022 AlgoExpert LLC. All rights reserved.\n\nclass FileSystem:\n    def __init__(self):\n        self.root = Directory(\"/\")\n\n    def create_directory(self, path):\n        before_last_node, new_directory_name = self._extract_from_path(path)\n        \n        new_directory = Directory(new_directory_name)\n\n        before_last_node.add_node(new_directory)\n\n    def create_file(self, path, contents):\n        before_last_node, new_file_name = self._extract_from_path(path)\n        \n        new_file = File(new_file_name)\n        new_file.write_contents(contents)\n\n        before_last_node.add_node(new_file)\n\n    def read_file(self, path):\n        before_last_node, file_name = self._extract_from_path(path)\n\n        if file_name not in before_last_node.children:\n            raise ValueError(f\"File not found: {file_name}.\")\n            \n        return before_last_node.children[file_name].contents\n\n    def delete_directory_or_file(self, path):\n        before_last_node, node_to_delete_name = self._extract_from_path(path)\n\n        if node_to_delete_name not in before_last_node.children:\n            raise ValueError(f\"Node not found: {node_to_delete_name}.\")\n            \n        before_last_node.delete_node(node_to_delete_name)\n\n    def size(self):\n        size = 0\n        nodes = [self.root]\n        while len(nodes) \u003e 0:\n            current_node = nodes.pop()\n            if isinstance(current_node, Directory):\n                children = list(current_node.children.values())\n                nodes.extend(children)\n                continue\n\n            if isinstance(current_node, File):\n                size += len(current_node)\n\n        return size\n\n    def __str__(self):\n        return f\"*** FileSystem ***\\n\" + self.root.__str__() + \"\\n***\"\n    \n    @staticmethod\n    def _validate_path(path):\n        if not path.startswith(\"/\"):\n            raise ValueError(\"Path should start with `/`.\")\n\n    def _extract_from_path(self, path):\n        FileSystem._validate_path(path)\n\n        path_node_names = path[1:].split(\"/\")\n        middle_node_names = path_node_names[:-1]\n        last_node_name = path_node_names[-1]\n\n        before_last_node = self._find_bottom_node(middle_node_names)\n\n        if not isinstance(before_last_node, Directory):\n            raise ValueError(f\"{before_last_node.name} isn't a directory.\")\n        \n        return (before_last_node, last_node_name)\n\n    def _find_bottom_node(self, node_names):\n        current_node = self.root\n        for node_name in node_names:\n            if not isinstance(current_node, Directory):\n                raise ValueError(f\"{current_node.name} isn't a directory.\")\n\n            if node_name not in current_node.children:\n                raise ValueError(f\"Node not found: {node_name}.\")\n\n            current_node = current_node.children[node_name]\n            \n        return current_node\n\n\nclass Node:\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return f\"{self.name} ({type(self).__name__})\"\n\n\nclass Directory(Node):\n    def __init__(self, name):\n        super().__init__(name)\n        self.children = {}\n\n    def add_node(self, node):\n        self.children[node.name] = node\n\n    def delete_node(self, name):\n        del self.children[name]\n\n    def __str__(self):\n        string = super().__str__()\n\n        children_strings = []\n        for child in list(self.children.values()):\n            child_string = child.__str__().rstrip()\n            children_strings.append(child_string)\n\n        children_combined_string = indent(\"\\n\".join(children_strings), 2)\n        string += \"\\n\" + children_combined_string.rstrip()\n        return string\n\n\nclass File(Node):\n    def __init__(self, name):\n        super().__init__(name)\n        self.contents = \"\"\n\n    def write_contents(self, contents):\n        self.contents = contents\n\n    def __len__(self):\n        return len(self.contents)\n\n    def __str__(self):\n        return super().__str__() + f\" | {len(self)} characters\"\n\n\ndef indent(string, number_of_spaces):\n    spaces = \" \" * number_of_spaces\n    lines = string.split(\"\\n\")\n    indented_lines = [spaces + line for line in lines]\n    return \"\\n\".join(indented_lines)"],"solutionsDisabled":false,"startingCode":"class FileSystem:\n    def __init__(self):\n        self.root = Directory(\"/\")\n\n    def create_directory(self, path):\n        # Write your code here.\n        pass\n\n    def create_file(self, path, contents):\n        # Write your code here.\n        pass\n\n    def read_file(self, path):\n        # Write your code here.\n        pass\n\n    def delete_directory_or_file(self, path):\n        # Write your code here.\n        pass\n\n    def size(self):\n        # Write your code here.\n        pass\n\n    def __str__(self):\n        return f\"*** FileSystem ***\\n\" + self.root.__str__() + \"\\n***\"\n    \n    @staticmethod\n    def _validate_path(path):\n        if not path.startswith(\"/\"):\n            raise ValueError(\"Path should start with `/`.\")\n\n\n    def _find_bottom_node(self, node_names):\n        # Write your code here.\n        pass\n\n\nclass Node:\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return f\"{self.name} ({type(self).__name__})\"\n\n\nclass Directory(Node):\n    def __init__(self, name):\n        super().__init__(name)\n        self.children = {}\n\n    def add_node(self, node):\n        self.children[node.name] = node\n\n    def delete_node(self, name):\n        del self.children[name]\n\n    def __str__(self):\n        string = super().__str__()\n\n        children_strings = []\n        for child in list(self.children.values()):\n            child_string = child.__str__().rstrip()\n            children_strings.append(child_string)\n\n        children_combined_string = indent(\"\\n\".join(children_strings), 2)\n        string += \"\\n\" + children_combined_string.rstrip()\n        return string\n\n\nclass File(Node):\n    def __init__(self, name):\n        super().__init__(name)\n        self.contents = \"\"\n\n    def write_contents(self, contents):\n        self.contents = contents\n\n    def __len__(self):\n        return len(self.contents)\n\n    def __str__(self):\n        return super().__str__() + f\" | {len(self)} characters\"\n\n\ndef indent(string, number_of_spaces):\n    spaces = \" \" * number_of_spaces\n    lines = string.split(\"\\n\")\n    indented_lines = [spaces + line for line in lines]\n    return \"\\n\".join(indented_lines)\n","unitTests":"import unittest\n\nfrom program import FileSystem\n\n\nclass TestProgram(unittest.TestCase):\n    def test_case_1(self):\n        fs = FileSystem()\n        fs.create_directory(\"/dir1\")\n        fs.create_directory(\"/dir2\")\n        fs.create_directory(\"/dir1/dir3\")\n        with self.assertRaises(ValueError):\n            fs.create_directory(\"/dir3/dir4\")\n\n    def test_case_2(self):\n        fs = FileSystem()\n        fs.create_file(\"/tim.txt\", \"Tim is great!\")\n        with self.assertRaises(ValueError):\n            fs.create_file(\"/dir1/simon.txt\", \"ProgrammingExpert is fun!\")\n        self.assertEqual(\"Tim is great!\", fs.read_file(\"/tim.txt\"))\n\n    def test_case_3(self):\n        fs = FileSystem()\n        fs.create_file(\"/tim.txt\", \"12345\")\n        self.assertEqual(fs.size(), 5)\n        fs.create_file(\"/alex.txt\", \"67890\")\n        self.assertEqual(fs.size(), 10)\n\n    def test_case_4(self):\n        fs = FileSystem()\n        fs.create_directory(\"/dir1\")\n        fs.create_directory(\"/dir1/dir2\")\n        fs.create_directory(\"/dir1/dir2/dir3\")\n        fs.create_file(\"/dir1/dir2/file1.txt\", \"1\")\n        fs.create_file(\"/dir1/dir2/dir3/file2.txt\", \"1\")\n        self.assertEqual(fs.size(), 2)\n\n    def test_case_5(self):\n        fs = FileSystem()\n        with self.assertRaises(ValueError):\n            fs.delete_directory_or_file(\"/dir1\")\n        fs.create_directory(\"/dir1\")\n        fs.create_file(\"/dir1/simon.txt\", \"ProgrammingExpert is fun!\")\n        self.assertEqual(25, fs.size())\n        with self.assertRaises(ValueError):\n            fs.delete_directory_or_file(\"/dir2\")\n        fs.delete_directory_or_file(\"/dir1\")\n        self.assertEqual(0, fs.size())\n\n    def test_case_6(self):\n        fs = FileSystem()\n        fs.create_directory(\"/dir1\")\n        fs.create_directory(\"/dir1/dir2\")\n        fs.create_file(\"/dir1/dir2/file1.html\", \"Hello World\")\n        self.assertEqual(11, fs.size())\n        self.assertEqual(\"Hello World\", fs.read_file(\"/dir1/dir2/file1.html\"))\n        fs.delete_directory_or_file(\"/dir1\")\n        self.assertEqual(0, fs.size())\n        with self.assertRaises(ValueError):\n            fs.read_file(\"/dir1/dir2/file1.html\")\n"}},"spaceTime":"","submissionStatistics":{"correctCount":1069,"failureCount":8526},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"9680748","version":0,"video":{"annotations":[],"codeWalkthroughTime":1475,"duration":23,"instructor":"Tim Ruscica","overviewTime":0,"vimeoId":"646108343"},"visualization":{"inputType":null,"outputType":null}},"difficulty":1,"instructor":"Tim Ruscica","name":"FileSystem Implementation","releaseDate":"0001-01-01T00:00:00Z","type":"CODING_STANDARD","uid":"9680748"}]}
